git : warning: in the working copy of 'src/games/smashup/abilities/pirates.ts', LF wil
l be replaced by CRLF the next time Git touches it
所在位置 行:1 字符: 1
+ git -C D:\gongzuo\web\BordGame --no-pager diff -- src/games/smashup/a ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (warning: in the... Git touches it:String 
   ) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError
 
diff --git a/src/games/smashup/abilities/pirates.ts b/src/games/smashup/abilities/pirates.ts
index 685091f..2dd9f46 100644
--- a/src/games/smashup/abilities/pirates.ts
+++ b/src/games/smashup/abilities/pirates.ts
@@ -6,12 +6,15 @@
 
 import { registerAbility } from '../domain/abilityRegistry';
 import type { AbilityContext, AbilityResult } from '../domain/abilityRegistry';
-import { destroyMinion, addPowerCounter, moveMinion, getMinionPower, setPromptContinuation, buildMinionTargetOptions, buildBaseTargetOptions } from '../domain/abilityHelpers';
-import type { SmashUpEvent, MinionCardDef } from '../domain/types';
+import { destroyMinion, addPowerCounter, moveMinion, getMinionPower, requestChoice, buildMinionTargetOptions, buildBaseTargetOptions } from '../domain/abilityHelpers';
+import type { SmashUpEvent, MinionCardDef, SmashUpCore, MinionDestroyedEvent } from '../domain/types';
+import { SU_EVENTS } from '../domain/types';
 import { registerPromptContinuation } from '../domain/promptContinuation';
 import { getCardDef, getBaseDef } from '../data/cards';
+import { registerTrigger, registerInterceptor } from '../domain/ongoingEffects';
+import type { TriggerContext } from '../domain/ongoingEffects';
 
-/** 娉ㄥ唽娴风洍娲剧郴鎵€鏈夎兘鍔?*/
+/** 娉ㄥ唽娴风洍娲剧郴鎵€鏈夎兘锟?*/
 export function registerPirateAbilities(): void {
     registerAbility('pirate_saucy_wench', 'onPlay', pirateSaucyWench);
     registerAbility('pirate_broadside', 'onPlay', pirateBroadside);
@@ -19,15 +22,25 @@ export function registerPirateAbilities(): void {
     registerAbility('pirate_swashbuckling', 'onPlay', pirateSwashbuckling);
     // 鐐歌嵂妗讹細娑堢伃宸辨柟闅忎粠锛岀劧鍚庢秷鐏悓鍩哄湴鎵€鏈夊姏閲忊墹琚秷鐏殢浠庣殑闅忎粠
     registerAbility('pirate_powderkeg', 'onPlay', piratePowderkeg);
-    // 灏忚墖锛堣鍔ㄥ崱锛夛細绉诲姩鑷冲涓や釜宸辨柟闅忎粠鍒板叾浠栧熀鍦?+    // 灏忚墖锛堣鍔ㄥ崱锛夛細绉诲姩鑷冲涓や釜宸辨柟闅忎粠鍒板叾浠栧熀锟?
     registerAbility('pirate_dinghy', 'onPlay', pirateDinghy);
-    // 涓婃捣锛堣鍔ㄥ崱锛夛細绉诲姩涓€涓鎵嬮殢浠庡埌鍙︿竴涓熀鍦?+    // 鍏ㄩ€熻埅琛岋紙鐗规畩琛屽姩鍗★級锛氱Щ鍔ㄥ繁鏂逛换鎰忔暟閲忛殢浠庡埌鍏朵粬鍩哄湴
+    registerAbility('pirate_full_sail', 'onPlay', pirateFullSail);
+    // 涓婃捣锛堣鍔ㄥ崱锛夛細绉诲姩涓€涓鎵嬮殢浠庡埌鍙︿竴涓熀锟?
     registerAbility('pirate_shanghai', 'onPlay', pirateShanghai);
-    // 娴风嫍锛堣鍔ㄥ崱锛夛細绉诲姩涓€涓殢浠庡埌鍙︿竴涓熀鍦?+    // 娴风嫍锛堣鍔ㄥ崱锛夛細绉诲姩涓€涓殢浠庡埌鍙︿竴涓熀锟?
     registerAbility('pirate_sea_dogs', 'onPlay', pirateSeaDogs);
+
+    // === ongoing 鏁堟灉娉ㄥ唽 ===
+    // 娴风洍鐜嬶細鍩哄湴璁″垎鍓嶇Щ鍔ㄥ埌璇ュ熀锟?
+    registerTrigger('pirate_king', 'beforeScoring', pirateKingBeforeScoring);
+    // 鍓畼锛氬熀鍦拌鍒嗗悗绉诲姩鍒板叾浠栧熀鍦帮紙鑰岄潪寮冪墝鍫嗭級
+    registerTrigger('pirate_first_mate', 'afterScoring', pirateFirstMateAfterScoring);
+    // 娴风洍锛堟捣鐩楋級锛氳娑堢伃鏃剁Щ鍔ㄥ埌鍏朵粬鍩哄湴鑰岄潪杩涘叆寮冪墝锟?
+    registerInterceptor('pirate_buccaneer', buccaneerDestroyInterceptor);
 }
 
-/** 绮楅瞾灏戝 onPlay锛氭秷鐏湰鍩哄湴涓€涓姏閲忊墹2鐨勯殢浠?*/
+/** 绮楅瞾灏戝 onPlay锛氭秷鐏湰鍩哄湴涓€涓姏閲忊墹2鐨勯殢锟?*/
 function pirateSaucyWench(ctx: AbilityContext): AbilityResult {
     const base = ctx.state.bases[ctx.baseIndex];
     if (!base) return { events: [] };
@@ -35,9 +48,6 @@ function pirateSaucyWench(ctx: AbilityContext): AbilityResult {
         m => m.uid !== ctx.cardUid && getMinionPower(ctx.state, m, ctx.baseIndex) <= 2
     );
     if (targets.length === 0) return { events: [] };
-    if (targets.length === 1) {
-        return { events: [destroyMinion(targets[0].uid, targets[0].defId, ctx.baseIndex, targets[0].owner, 'pirate_saucy_wench', ctx.now)] };
-    }
     const options = targets.map(t => {
         const def = getCardDef(t.defId) as MinionCardDef | undefined;
         const name = def?.name ?? t.defId;
@@ -45,54 +55,55 @@ function pirateSaucyWench(ctx: AbilityContext): AbilityResult {
         return { uid: t.uid, defId: t.defId, baseIndex: ctx.baseIndex, label: `${name} (鍔涢噺 ${power})` };
     });
     return {
-        events: [setPromptContinuation({ abilityId: 'pirate_saucy_wench', playerId: ctx.playerId, data: { promptConfig: { title: '閫夋嫨瑕佹秷鐏殑鍔涢噺鈮?鐨勯殢浠?, options: buildMinionTargetOptions(options) } } }, ctx.now)],
+        events: [requestChoice({ abilityId: 'pirate_saucy_wench', playerId: ctx.playerId, promptConfig: { title: '閫夋嫨瑕佹秷鐏殑鍔涢噺锟?鐨勯殢锟?, options: buildMinionTargetOptions(options) } }, ctx.now)],
     };
 }
 
-/** 渚х考寮€鐐?onPlay锛氭秷鐏竴涓帺瀹跺湪浣犳湁闅忎粠鐨勫熀鍦扮殑鎵€鏈夊姏閲忊墹2闅忎粠锛圡VP锛氳嚜鍔ㄩ€夊鎵嬶級 */
+/** 渚х考寮€锟?onPlay锛氶€夋嫨涓€涓锟?涓€涓綘鏈夐殢浠庣殑鍩哄湴锛屾秷鐏瀵规墜鍦ㄨ鍩哄湴鎵€鏈夊姏閲忊墹2鐨勯殢锟?*/
 function pirateBroadside(ctx: AbilityContext): AbilityResult {
-    const events: SmashUpEvent[] = [];
-
-    // 鎵惧埌浣犳湁闅忎粠鐨勫熀鍦?+    // 鏀堕泦鎵€鏈夊彲鑳界殑 (鍩哄湴, 瀵规墜) 缁勫悎
+    const candidates: { baseIndex: number; opponentId: string; count: number; label: string }[] = [];
     for (let i = 0; i < ctx.state.bases.length; i++) {
         const base = ctx.state.bases[i];
-        const myMinions = base.minions.filter(m => m.controller === ctx.playerId);
-        if (myMinions.length === 0) continue;
-
-        // 鎵惧埌璇ュ熀鍦颁笂瀵规墜鍔涢噺鈮?鐨勯殢浠庢渶澶氱殑鐜╁
+        if (!base.minions.some(m => m.controller === ctx.playerId)) continue;
         const opponentCounts = new Map<string, number>();
         for (const m of base.minions) {
             if (m.controller !== ctx.playerId && getMinionPower(ctx.state, m, i) <= 2) {
                 opponentCounts.set(m.controller, (opponentCounts.get(m.controller) || 0) + 1);
             }
         }
-        if (opponentCounts.size === 0) continue;
-
-        // MVP锛氶€夐殢浠庢渶澶氱殑瀵规墜锛屽湪绗竴涓鍚堟潯浠剁殑鍩哄湴
-        let bestOpponent = '';
-        let bestCount = 0;
+        const baseDef = getBaseDef(base.defId);
+        const baseName = baseDef?.name ?? `鍩哄湴 ${i + 1}`;
         for (const [pid, count] of opponentCounts) {
-            if (count > bestCount) {
-                bestCount = count;
-                bestOpponent = pid;
-            }
+            candidates.push({ baseIndex: i, opponentId: pid, count, label: `${baseName} 锟?瀵规墜 ${pid}锟?{count}涓急闅忎粠锛塦 });
         }
+    }
+    if (candidates.length === 0) return { events: [] };
+    const options = candidates.map((c, i) => ({ id: `target-${i}`, label: c.label, value: { baseIndex: c.baseIndex, opponentId: c.opponentId } }));
+    return {
+        events: [requestChoice({
+            abilityId: 'pirate_broadside',
+            playerId: ctx.playerId,
+            promptConfig: { title: '閫夋嫨鍩哄湴鍜屽鎵嬶紝娑堢伃璇ュ鎵嬫墍鏈夊姏閲忊墹2鐨勯殢锟?, options },
+        }, ctx.now)],
+    };
+}
 
-        // 娑堢伃璇ュ鎵嬪湪璇ュ熀鍦版墍鏈夊姏閲忊墹2鐨勯殢浠?-        for (const m of base.minions) {
-            if (m.controller === bestOpponent && getMinionPower(ctx.state, m, i) <= 2) {
-                events.push(destroyMinion(m.uid, m.defId, i, m.owner, 'pirate_broadside', ctx.now));
-            }
+function executeBroadside(ctx: AbilityContext, baseIndex: number, opponentId: string): AbilityResult {
+    const events: SmashUpEvent[] = [];
+    const base = ctx.state.bases[baseIndex];
+    if (!base) return { events: [] };
+    for (const m of base.minions) {
+        if (m.controller === opponentId && getMinionPower(ctx.state, m, baseIndex) <= 2) {
+            events.push(destroyMinion(m.uid, m.defId, baseIndex, m.owner, 'pirate_broadside', ctx.now));
         }
-        break; // 鍙€変竴涓熀鍦?     }
-
     return { events };
 }
 
-/** 鍔犲啘鐐?onPlay锛氭秷鐏嚦澶氫袱涓姏閲忊墹2鐨勯殢浠?*/
+/** 鍔犲啘锟?onPlay锛氭秷鐏嚦澶氫袱涓姏閲忊墹2鐨勯殢锟?*/
 function pirateCannon(ctx: AbilityContext): AbilityResult {
-    // 鏀堕泦鎵€鏈夊姏閲忊墹2鐨勯殢浠?+    // 鏀堕泦鎵€鏈夊姏閲忊墹2鐨勯殢锟?
     const allTargets: { uid: string; defId: string; baseIndex: number; owner: string; label: string }[] = [];
     for (let i = 0; i < ctx.state.bases.length; i++) {
         for (const m of ctx.state.bases[i].minions) {
@@ -107,22 +118,19 @@ function pirateCannon(ctx: AbilityContext): AbilityResult {
         }
     }
     if (allTargets.length === 0) return { events: [] };
-    // 0-1涓洰鏍囪嚜鍔ㄦ秷鐏?-    if (allTargets.length === 1) {
-        return { events: [destroyMinion(allTargets[0].uid, allTargets[0].defId, allTargets[0].baseIndex, allTargets[0].owner, 'pirate_cannon', ctx.now)] };
-    }
-    // 澶氱洰鏍囷細Prompt 閫夋嫨绗竴涓?+    // Prompt 閫夋嫨绗竴锟?
     const options = allTargets.map(t => ({ uid: t.uid, defId: t.defId, baseIndex: t.baseIndex, label: t.label }));
     return {
-        events: [setPromptContinuation({
+        events: [requestChoice({
             abilityId: 'pirate_cannon_choose_first',
             playerId: ctx.playerId,
-            data: { allTargetUids: allTargets.map(t => t.uid), promptConfig: { title: '閫夋嫨绗竴涓娑堢伃鐨勫姏閲忊墹2鐨勯殢浠庯紙鑷冲2涓級', options: buildMinionTargetOptions(options) } },
+            promptConfig: { title: '閫夋嫨绗竴涓娑堢伃鐨勫姏閲忊墹2鐨勯殢浠庯紙鑷冲2涓級', options: buildMinionTargetOptions(options) },
+                        continuationContext: { allTargetUids: allTargets.map(t => t.uid), },
         }, ctx.now)],
     };
 }
 
-/** 铏氬紶澹板娍 onPlay锛氫綘鐨勬瘡涓殢浠?1鍔涢噺鐩村埌鍥炲悎缁撴潫 */
+/** 铏氬紶澹板娍 onPlay锛氫綘鐨勬瘡涓殢锟?1鍔涢噺鐩村埌鍥炲悎缁撴潫 */
 function pirateSwashbuckling(ctx: AbilityContext): AbilityResult {
     const events: SmashUpEvent[] = [];
 
@@ -138,50 +146,151 @@ function pirateSwashbuckling(ctx: AbilityContext): AbilityResult {
     return { events };
 }
 
-// TODO: pirate_king (special) - 鍩哄湴璁″垎鍓嶇Щ鍔ㄥ埌璇ュ熀鍦帮紙闇€瑕?beforeScoring 鏃舵満锛?-// TODO: pirate_buccaneer (special) - 琚秷鐏椂绉诲姩鍒板叾浠栧熀鍦帮紙闇€瑕?onDestroy 鏇夸唬鏁堟灉锛?-// TODO: pirate_first_mate (special) - 鍩哄湴璁″垎鍚庣Щ鍔ㄥ埌鍏朵粬鍩哄湴锛堥渶瑕?afterScoring 鏃舵満锛?-// TODO: pirate_full_sail (special action) - 绉诲姩浠绘剰鏁伴噺闅忎粠锛堥渶瑕?Prompt + special 鏃舵満锛?+/** 鍏ㄩ€熻埅锟?onPlay锛氱Щ鍔ㄥ繁鏂逛换鎰忔暟閲忛殢浠庡埌鍏朵粬鍩哄湴锛堝锟?Prompt 寰幆锟?*/
+function pirateFullSail(ctx: AbilityContext): AbilityResult {
+    return { events: buildFullSailChooseMinionPrompt(ctx.state, ctx.playerId, ctx.now, []) };
+}
 
-/** 灏忚墖 onPlay锛氱Щ鍔ㄨ嚦澶氫袱涓繁鏂归殢浠庡埌鍏朵粬鍩哄湴锛圡VP锛氳嚜鍔ㄩ€夊姏閲忔渶浣庣殑涓や釜绉诲埌闅忎粠鏈€灏戠殑鍩哄湴锛?*/
-function pirateDinghy(ctx: AbilityContext): AbilityResult {
+/** 鏋勫缓 full_sail "閫夋嫨闅忎粠" Prompt锛宮ovedUids 涓哄凡绉诲姩鐨勯殢锟?uid 鍒楄〃 */
+function buildFullSailChooseMinionPrompt(
+    state: SmashUpCore,
+    playerId: string,
+    now: number,
+    movedUids: string[],
+): SmashUpEvent[] {
+    const myMinions: { uid: string; defId: string; baseIndex: number; label: string }[] = [];
+    for (let i = 0; i < state.bases.length; i++) {
+        for (const m of state.bases[i].minions) {
+            if (m.controller === playerId && !movedUids.includes(m.uid)) {
+                const def = getCardDef(m.defId) as MinionCardDef | undefined;
+                const name = def?.name ?? m.defId;
+                const baseDef = getBaseDef(state.bases[i].defId);
+                const baseName = baseDef?.name ?? `鍩哄湴 ${i + 1}`;
+                const power = getMinionPower(state, m, i);
+                myMinions.push({ uid: m.uid, defId: m.defId, baseIndex: i, label: `${name} (鍔涢噺 ${power}) @ ${baseName}` });
+            }
+        }
+    }
+    if (myMinions.length === 0) return [];
+    // 鏋勫缓閫夐」锛氶殢浠庡垪锟?+ "瀹屾垚" 閫夐」
+    const options = [
+        ...buildMinionTargetOptions(myMinions),
+        { id: 'done', label: '瀹屾垚绉诲姩', value: { done: true } },
+    ];
+    return [requestChoice({
+        abilityId: 'pirate_full_sail_choose_minion',
+        playerId,
+        promptConfig: { title: '閫夋嫨瑕佺Щ鍔ㄧ殑宸辨柟闅忎粠锛堟垨瀹屾垚锟?, options },
+                        continuationContext: { movedUids, },
+    }, now)];
+}
+
+// TODO: pirate_full_sail special 鏃舵満锛堝熀鍦拌鍒嗗墠鎵撳嚭锟?
+// 瑙勫垯锛欶ull Sail 锟?special 琛屽姩鍗★紝搴斿湪鍩哄湴璁″垎鍓嶏紙beforeScoring锛夋墦鍑猴拷?
+// 褰撳墠瀹炵幇锟?onPlay锛堟墜鍔ㄦ墦鍑猴級锛岄渶锟?beforeScoring 闃舵锟?special action 鏈哄埗鏀寔锟?
+// 娓呯悊瑙﹀彂鏉′欢锛氬綋 special action 鏈哄埗锛堝厑璁稿湪 beforeScoring 闃舵浠庢墜鐗屾墦锟?special 鍗★級瀹炵幇鍚庡洖濉拷?
+
+// ============================================================================
+// 浜嬩欢鎷︽埅鍣紙鏇夸唬鏁堟灉锟?
+// ============================================================================
+
+/**
+ * 娴风洍 (Buccaneer) 鏇夸唬鏁堟灉锛氳娑堢伃鏃剁Щ鍔ㄥ埌鍏朵粬鍩哄湴
+ *
+ * MVP锛氳嚜鍔ㄩ€夋嫨绗竴涓彲鐢ㄧ殑鍏朵粬鍩哄湴銆傛棤鍏朵粬鍩哄湴鏃舵甯告秷鐏拷?
+ */
+function buccaneerDestroyInterceptor(
+    state: SmashUpCore,
+    event: SmashUpEvent
+): SmashUpEvent | undefined {
+    if (event.type !== SU_EVENTS.MINION_DESTROYED) return undefined;
+    const { minionUid, minionDefId, fromBaseIndex } = (event as MinionDestroyedEvent).payload;
+    if (minionDefId !== 'pirate_buccaneer') return undefined;
+
+    // 鎵惧埌绗竴涓彲鐢ㄧ殑鍏朵粬鍩哄湴
+    for (let i = 0; i < state.bases.length; i++) {
+        if (i === fromBaseIndex) continue;
+        return moveMinion(minionUid, minionDefId, fromBaseIndex, i, 'pirate_buccaneer', event.timestamp);
+    }
+    // 鏃犲叾浠栧熀鍦板彲绉伙紝涓嶆嫤鎴紙姝ｅ父娑堢伃锟?
+    return undefined;
+}
+
+// ============================================================================
+// ongoing 鏁堟灉瑙﹀彂锟?
+// ============================================================================
+
+/** 娴风洍锟?beforeScoring锛氳嚜鍔ㄧЩ鍔ㄥ埌鍗冲皢璁″垎鐨勫熀鍦帮紙MVP锛氳嚜鍔ㄦ墽琛岋紝涓嶈闂級 */
+function pirateKingBeforeScoring(ctx: TriggerContext): SmashUpEvent[] {
     const events: SmashUpEvent[] = [];
-    // 鏀堕泦鎵€鏈夊繁鏂归殢浠?-    const myMinions: { uid: string; defId: string; baseIndex: number; power: number }[] = [];
+    const scoringBaseIndex = ctx.baseIndex;
+    if (scoringBaseIndex === undefined) return events;
+
+    // 閬嶅巻鎵€鏈夊熀鍦帮紝鎵惧埌涓嶅湪璁″垎鍩哄湴涓婄殑 pirate_king 骞剁Щ杩囧幓
     for (let i = 0; i < ctx.state.bases.length; i++) {
+        if (i === scoringBaseIndex) continue;
         for (const m of ctx.state.bases[i].minions) {
-            if (m.controller === ctx.playerId) {
-                myMinions.push({ uid: m.uid, defId: m.defId, baseIndex: i, power: getMinionPower(ctx.state, m, i) });
+            if (m.defId === 'pirate_king') {
+                events.push(moveMinion(m.uid, m.defId, i, scoringBaseIndex, 'pirate_king', ctx.now));
             }
         }
     }
-    if (myMinions.length === 0) return { events: [] };
+    return events;
+}
+
+/** 娴风洍鍓畼 afterScoring锛氱Щ鍔ㄥ埌鍏朵粬鍩哄湴鑰岄潪杩涘叆寮冪墝鍫嗭紙MVP锛氳嚜鍔ㄩ€夌涓€涓叾浠栧熀鍦帮級 */
+function pirateFirstMateAfterScoring(ctx: TriggerContext): SmashUpEvent[] {
+    const events: SmashUpEvent[] = [];
+    const scoringBaseIndex = ctx.baseIndex;
+    if (scoringBaseIndex === undefined) return events;
 
-    // 閫夊姏閲忔渶浣庣殑鑷冲2涓?-    myMinions.sort((a, b) => a.power - b.power);
-    const toMove = myMinions.slice(0, 2);
+    const base = ctx.state.bases[scoringBaseIndex];
+    if (!base) return events;
 
-    for (const m of toMove) {
-        // 鎵句竴涓笉鍚岀殑鍩哄湴锛堥殢浠庢渶灏戠殑锛?-        let bestBase = -1;
-        let bestCount = Infinity;
+    for (const m of base.minions) {
+        if (m.defId !== 'pirate_first_mate') continue;
+        // 閫夋嫨绗竴涓彲鐢ㄧ殑鍏朵粬鍩哄湴
         for (let i = 0; i < ctx.state.bases.length; i++) {
-            if (i === m.baseIndex) continue;
-            if (ctx.state.bases[i].minions.length < bestCount) {
-                bestCount = ctx.state.bases[i].minions.length;
-                bestBase = i;
-            }
+            if (i === scoringBaseIndex) continue;
+            events.push(moveMinion(m.uid, m.defId, scoringBaseIndex, i, 'pirate_first_mate', ctx.now));
+            break;
         }
-        if (bestBase >= 0) {
-            events.push(moveMinion(m.uid, m.defId, m.baseIndex, bestBase, 'pirate_dinghy', ctx.now));
+    }
+    return events;
+}
+
+/** 灏忚墖 onPlay锛氱Щ鍔ㄨ嚦澶氫袱涓繁鏂归殢浠庡埌鍏朵粬鍩哄湴 */
+function pirateDinghy(ctx: AbilityContext): AbilityResult {
+    // 鏀堕泦鎵€鏈夊繁鏂归殢锟?
+    const myMinions: { uid: string; defId: string; baseIndex: number; power: number; label: string }[] = [];
+    for (let i = 0; i < ctx.state.bases.length; i++) {
+        for (const m of ctx.state.bases[i].minions) {
+            if (m.controller === ctx.playerId) {
+                const power = getMinionPower(ctx.state, m, i);
+                const def = getCardDef(m.defId) as MinionCardDef | undefined;
+                const name = def?.name ?? m.defId;
+                const baseDef = getBaseDef(ctx.state.bases[i].defId);
+                const baseName = baseDef?.name ?? `鍩哄湴 ${i + 1}`;
+                myMinions.push({ uid: m.uid, defId: m.defId, baseIndex: i, power, label: `${name} (鍔涢噺 ${power}) @ ${baseName}` });
+            }
         }
     }
-    return { events };
+    if (myMinions.length === 0) return { events: [] };
+    const options = myMinions.map(m => ({ uid: m.uid, defId: m.defId, baseIndex: m.baseIndex, label: m.label }));
+    // 绗竴姝ワ細閫夋嫨绗竴涓殢锟?
+    return {
+        events: [requestChoice({
+            abilityId: 'pirate_dinghy_choose_first',
+            playerId: ctx.playerId,
+            promptConfig: { title: '閫夋嫨瑕佺Щ鍔ㄧ殑宸辨柟闅忎粠锛堣嚦锟?涓紝锟?涓級', options: buildMinionTargetOptions(options) },
+                        continuationContext: { remaining: 2, },
+        }, ctx.now)],
+    };
 }
 
-/** 涓婃捣 onPlay锛氱Щ鍔ㄤ竴涓鎵嬮殢浠庡埌鍙︿竴涓熀鍦?*/
+/** 涓婃捣 onPlay锛氱Щ鍔ㄤ竴涓鎵嬮殢浠庡埌鍙︿竴涓熀锟?*/
 function pirateShanghai(ctx: AbilityContext): AbilityResult {
-    // 鏀堕泦鎵€鏈夊鎵嬮殢浠?+    // 鏀堕泦鎵€鏈夊鎵嬮殢锟?
     const targets: { uid: string; defId: string; baseIndex: number; power: number; label: string }[] = [];
     for (let i = 0; i < ctx.state.bases.length; i++) {
         for (const m of ctx.state.bases[i].minions) {
@@ -195,27 +304,20 @@ function pirateShanghai(ctx: AbilityContext): AbilityResult {
         }
     }
     if (targets.length === 0) return { events: [] };
-    if (targets.length === 1 && ctx.state.bases.length <= 2) {
-        // 鍗曠洰鏍囦笖鍙湁涓€涓叾浠栧熀鍦帮紝鑷姩鎵ц
-        const t = targets[0];
-        const destBase = ctx.state.bases.findIndex((_, idx) => idx !== t.baseIndex);
-        if (destBase < 0) return { events: [] };
-        return { events: [moveMinion(t.uid, t.defId, t.baseIndex, destBase, 'pirate_shanghai', ctx.now)] };
-    }
     // Prompt 閫夋嫨鐩爣闅忎粠
     const options = targets.map(t => ({ uid: t.uid, defId: t.defId, baseIndex: t.baseIndex, label: t.label }));
     return {
-        events: [setPromptContinuation({
+        events: [requestChoice({
             abilityId: 'pirate_shanghai_choose_minion',
             playerId: ctx.playerId,
-            data: { promptConfig: { title: '閫夋嫨瑕佺Щ鍔ㄧ殑瀵规墜闅忎粠', options: buildMinionTargetOptions(options) } },
+            promptConfig: { title: '閫夋嫨瑕佺Щ鍔ㄧ殑瀵规墜闅忎粠', options: buildMinionTargetOptions(options) },
         }, ctx.now)],
     };
 }
 
-/** 娴风嫍 onPlay锛氱Щ鍔ㄤ竴涓殢浠庡埌鍙︿竴涓熀鍦?*/
+/** 娴风嫍 onPlay锛氱Щ鍔ㄤ竴涓殢浠庡埌鍙︿竴涓熀锟?*/
 function pirateSeaDogs(ctx: AbilityContext): AbilityResult {
-    // 鏀堕泦鎵€鏈夐殢浠庯紙浠绘剰鐜╁锛?+    // 鏀堕泦鎵€鏈夐殢浠庯紙浠绘剰鐜╁锟?
     const targets: { uid: string; defId: string; baseIndex: number; power: number; label: string }[] = [];
     for (let i = 0; i < ctx.state.bases.length; i++) {
         for (const m of ctx.state.bases[i].minions) {
@@ -228,25 +330,19 @@ function pirateSeaDogs(ctx: AbilityContext): AbilityResult {
         }
     }
     if (targets.length === 0) return { events: [] };
-    if (targets.length === 1 && ctx.state.bases.length <= 2) {
-        const t = targets[0];
-        const destBase = ctx.state.bases.findIndex((_, idx) => idx !== t.baseIndex);
-        if (destBase < 0) return { events: [] };
-        return { events: [moveMinion(t.uid, t.defId, t.baseIndex, destBase, 'pirate_sea_dogs', ctx.now)] };
-    }
     const options = targets.map(t => ({ uid: t.uid, defId: t.defId, baseIndex: t.baseIndex, label: t.label }));
     return {
-        events: [setPromptContinuation({
+        events: [requestChoice({
             abilityId: 'pirate_sea_dogs_choose_minion',
             playerId: ctx.playerId,
-            data: { promptConfig: { title: '閫夋嫨瑕佺Щ鍔ㄧ殑闅忎粠', options: buildMinionTargetOptions(options) } },
+            promptConfig: { title: '閫夋嫨瑕佺Щ鍔ㄧ殑闅忎粠', options: buildMinionTargetOptions(options) },
         }, ctx.now)],
     };
 }
 
-/** 鐐歌嵂妗?onPlay锛氭秷鐏繁鏂归殢浠庯紝鐒跺悗娑堢伃鍚屽熀鍦版墍鏈夊姏閲忊墹琚秷鐏殢浠庣殑闅忎粠 */
+/** 鐐歌嵂锟?onPlay锛氭秷鐏繁鏂归殢浠庯紝鐒跺悗娑堢伃鍚屽熀鍦版墍鏈夊姏閲忊墹琚秷鐏殢浠庣殑闅忎粠 */
 function piratePowderkeg(ctx: AbilityContext): AbilityResult {
-    // 鏀堕泦鎵€鏈夊繁鏂归殢浠?+    // 鏀堕泦鎵€鏈夊繁鏂归殢锟?
     const myMinions: { uid: string; defId: string; power: number; baseIndex: number; owner: string; label: string }[] = [];
     for (let i = 0; i < ctx.state.bases.length; i++) {
         for (const m of ctx.state.bases[i].minions) {
@@ -260,16 +356,13 @@ function piratePowderkeg(ctx: AbilityContext): AbilityResult {
         }
     }
     if (myMinions.length === 0) return { events: [] };
-    if (myMinions.length === 1) {
-        return executePowderkeg(ctx, myMinions[0]);
-    }
-    // 澶氫釜宸辨柟闅忎粠锛歅rompt 閫夋嫨鐗虹壊鍝釜
+    // Prompt 閫夋嫨鐗虹壊鍝釜
     const options = myMinions.map(m => ({ uid: m.uid, defId: m.defId, baseIndex: m.baseIndex, label: m.label }));
     return {
-        events: [setPromptContinuation({
+        events: [requestChoice({
             abilityId: 'pirate_powderkeg',
             playerId: ctx.playerId,
-            data: { promptConfig: { title: '閫夋嫨瑕佺壓鐗茬殑宸辨柟闅忎粠锛堝悓鍩哄湴鍔涢噺鈮ゅ畠鐨勯殢浠庝篃浼氳娑堢伃锛?, options: buildMinionTargetOptions(options) } },
+            promptConfig: { title: '閫夋嫨瑕佺壓鐗茬殑宸辨柟闅忎粠锛堝悓鍩哄湴鍔涢噺鈮ゅ畠鐨勯殢浠庝篃浼氳娑堢伃锟?, options: buildMinionTargetOptions(options) },
         }, ctx.now)],
     };
 }
@@ -301,6 +394,7 @@ function buildMoveToBasePrompt(
     abilityId: string,
     playerId: string,
     now: number,
+    extraData?: Record<string, unknown>,
 ): SmashUpEvent[] {
     const candidates: { baseIndex: number; label: string }[] = [];
     for (let i = 0; i < state.bases.length; i++) {
@@ -309,24 +403,18 @@ function buildMoveToBasePrompt(
         candidates.push({ baseIndex: i, label: baseDef?.name ?? `鍩哄湴 ${i + 1}` });
     }
     if (candidates.length === 0) return [];
-    if (candidates.length === 1) {
-        return [moveMinion(minionUid, minionDefId, fromBaseIndex, candidates[0].baseIndex, abilityId, now)];
-    }
-    return [setPromptContinuation({
+    return [requestChoice({
         abilityId: `${abilityId}_choose_base`,
         playerId,
-        data: {
-            minionUid, minionDefId, fromBaseIndex,
-            promptConfig: { title: '閫夋嫨鐩爣鍩哄湴', options: buildBaseTargetOptions(candidates) },
-        },
+        promptConfig: { title: '閫夋嫨鐩爣鍩哄湴', options: buildBaseTargetOptions(candidates) },
+                        continuationContext: { ...extraData,
+            minionUid, minionDefId, fromBaseIndex, },
     }, now)];
 }
 
-import type { SmashUpCore } from '../domain/types';
-
-/** 娉ㄥ唽娴风洍娲剧郴鐨?Prompt 缁х画鍑芥暟 */
+/** 娉ㄥ唽娴风洍娲剧郴锟?Prompt 缁х画鍑芥暟 */
 export function registerPiratePromptContinuations(): void {
-    // 绮楅瞾灏戝锛氶€夋嫨鐩爣鍚庢秷鐏?+    // 绮楅瞾灏戝锛氶€夋嫨鐩爣鍚庢秷锟?
     registerPromptContinuation('pirate_saucy_wench', (ctx) => {
         const { minionUid, baseIndex } = ctx.selectedValue as { minionUid: string; baseIndex: number };
         const base = ctx.state.bases[baseIndex];
@@ -344,7 +432,7 @@ export function registerPiratePromptContinuations(): void {
         const target = base.minions.find(m => m.uid === minionUid);
         if (!target) return [];
         const events: SmashUpEvent[] = [destroyMinion(target.uid, target.defId, baseIndex, target.owner, 'pirate_cannon', ctx.now)];
-        // 妫€鏌ュ墿浣欏姏閲忊墹2鐨勯殢浠庯紙鎺掗櫎鍒氭秷鐏殑锛?+        // 妫€鏌ュ墿浣欏姏閲忊墹2鐨勯殢浠庯紙鎺掗櫎鍒氭秷鐏殑锟?
         const remaining: { uid: string; defId: string; baseIndex: number; label: string }[] = [];
         for (let i = 0; i < ctx.state.bases.length; i++) {
             for (const m of ctx.state.bases[i].minions) {
@@ -360,17 +448,11 @@ export function registerPiratePromptContinuations(): void {
             }
         }
         if (remaining.length === 0) return events;
-        if (remaining.length === 1) {
-            const r = remaining[0];
-            const rTarget = ctx.state.bases[r.baseIndex].minions.find(m => m.uid === r.uid);
-            if (rTarget) events.push(destroyMinion(r.uid, r.defId, r.baseIndex, rTarget.owner, 'pirate_cannon', ctx.now));
-            return events;
-        }
-        // 澶氫釜鍓╀綑鐩爣锛歅rompt 閫夋嫨绗簩涓?-        events.push(setPromptContinuation({
+        // Prompt 閫夋嫨绗簩涓紙鍙€夛級
+        events.push(requestChoice({
             abilityId: 'pirate_cannon_choose_second',
             playerId: ctx.playerId,
-            data: { promptConfig: { title: '閫夋嫨绗簩涓娑堢伃鐨勫姏閲忊墹2鐨勯殢浠庯紙鍙€夛級', options: buildMinionTargetOptions(remaining) } },
+            promptConfig: { title: '閫夋嫨绗簩涓娑堢伃鐨勫姏閲忊墹2鐨勯殢浠庯紙鍙€夛級', options: buildMinionTargetOptions(remaining) },
         }, ctx.now));
         return events;
     });
@@ -395,7 +477,7 @@ export function registerPiratePromptContinuations(): void {
         return buildMoveToBasePrompt(ctx.state, minionUid, minion.defId, baseIndex, 'pirate_shanghai', ctx.playerId, ctx.now);
     });
 
-    // 涓婃捣锛氶€夋嫨鍩哄湴鍚庣Щ鍔?+    // 涓婃捣锛氶€夋嫨鍩哄湴鍚庣Щ锟?
     registerPromptContinuation('pirate_shanghai_choose_base', (ctx) => {
         const { baseIndex: destBase } = ctx.selectedValue as { baseIndex: number };
         const data = ctx.data as { minionUid: string; minionDefId: string; fromBaseIndex: number };
@@ -412,14 +494,113 @@ export function registerPiratePromptContinuations(): void {
         return buildMoveToBasePrompt(ctx.state, minionUid, minion.defId, baseIndex, 'pirate_sea_dogs', ctx.playerId, ctx.now);
     });
 
-    // 娴风嫍锛氶€夋嫨鍩哄湴鍚庣Щ鍔?+    // 娴风嫍锛氶€夋嫨鍩哄湴鍚庣Щ锟?
     registerPromptContinuation('pirate_sea_dogs_choose_base', (ctx) => {
         const { baseIndex: destBase } = ctx.selectedValue as { baseIndex: number };
         const data = ctx.data as { minionUid: string; minionDefId: string; fromBaseIndex: number };
         return [moveMinion(data.minionUid, data.minionDefId, data.fromBaseIndex, destBase, 'pirate_sea_dogs', ctx.now)];
     });
 
-    // 鐐歌嵂妗讹細閫夋嫨鐗虹壊闅忎粠鍚庢墽琛?+    // 渚х考寮€鐐細閫夋嫨鍩哄湴+瀵规墜鍚庢墽锟?
+    registerPromptContinuation('pirate_broadside', (ctx) => {
+        const { baseIndex, opponentId } = ctx.selectedValue as { baseIndex: number; opponentId: string };
+        const base = ctx.state.bases[baseIndex];
+        if (!base) return [];
+        const events: SmashUpEvent[] = [];
+        for (const m of base.minions) {
+            if (m.controller === opponentId && getMinionPower(ctx.state, m, baseIndex) <= 2) {
+                events.push(destroyMinion(m.uid, m.defId, baseIndex, m.owner, 'pirate_broadside', ctx.now));
+            }
+        }
+        return events;
+    });
+
+    // 灏忚墖绗竴姝ワ細閫夋嫨绗竴涓殢浠庡悗锛岄€夋嫨鐩爣鍩哄湴
+    registerPromptContinuation('pirate_dinghy_choose_first', (ctx) => {
+        const { minionUid, baseIndex } = ctx.selectedValue as { minionUid: string; baseIndex: number };
+        const base = ctx.state.bases[baseIndex];
+        if (!base) return [];
+        const minion = base.minions.find(m => m.uid === minionUid);
+        if (!minion) return [];
+        return buildMoveToBasePrompt(ctx.state, minionUid, minion.defId, baseIndex, 'pirate_dinghy_first', ctx.playerId, ctx.now);
+    });
+
+    // 灏忚墖绗竴姝ラ€夊熀鍦板悗锛氱Щ鍔紝鐒跺悗Prompt閫夌浜屼釜闅忎粠锛堝彲閫夛級
+    registerPromptContinuation('pirate_dinghy_first_choose_base', (ctx) => {
+        const { baseIndex: destBase } = ctx.selectedValue as { baseIndex: number };
+        const data = ctx.data as { minionUid: string; minionDefId: string; fromBaseIndex: number };
+        const events: SmashUpEvent[] = [moveMinion(data.minionUid, data.minionDefId, data.fromBaseIndex, destBase, 'pirate_dinghy', ctx.now)];
+        // 妫€鏌ユ槸鍚﹁繕鏈夊叾浠栧繁鏂归殢浠庡彲绉诲姩
+        const remaining: { uid: string; defId: string; baseIndex: number; label: string }[] = [];
+        for (let i = 0; i < ctx.state.bases.length; i++) {
+            for (const m of ctx.state.bases[i].minions) {
+                if (m.controller === ctx.playerId && m.uid !== data.minionUid) {
+                    const def = getCardDef(m.defId) as MinionCardDef | undefined;
+                    const name = def?.name ?? m.defId;
+                    const baseDef = getBaseDef(ctx.state.bases[i].defId);
+                    const baseName = baseDef?.name ?? `鍩哄湴 ${i + 1}`;
+                    const power = getMinionPower(ctx.state, m, i);
+                    remaining.push({ uid: m.uid, defId: m.defId, baseIndex: i, label: `${name} (鍔涢噺 ${power}) @ ${baseName}` });
+                }
+            }
+        }
+        if (remaining.length === 0) return events;
+        // Prompt閫夌浜屼釜
+        events.push(requestChoice({
+            abilityId: 'pirate_dinghy_choose_second',
+            playerId: ctx.playerId,
+            promptConfig: { title: '閫夋嫨绗簩涓绉诲姩鐨勯殢浠庯紙鍙€夛級', options: buildMinionTargetOptions(remaining) },
+        }, ctx.now));
+        return events;
+    });
+
+    // 灏忚墖绗簩姝ワ細閫夋嫨绗簩涓殢浠庡悗锛岄€夋嫨鐩爣鍩哄湴
+    registerPromptContinuation('pirate_dinghy_choose_second', (ctx) => {
+        const { minionUid, baseIndex } = ctx.selectedValue as { minionUid: string; baseIndex: number };
+        const base = ctx.state.bases[baseIndex];
+        if (!base) return [];
+        const minion = base.minions.find(m => m.uid === minionUid);
+        if (!minion) return [];
+        return buildMoveToBasePrompt(ctx.state, minionUid, minion.defId, baseIndex, 'pirate_dinghy_second', ctx.playerId, ctx.now);
+    });
+
+    // 灏忚墖绗簩姝ラ€夊熀鍦板悗锛氱Щ锟?
+    registerPromptContinuation('pirate_dinghy_second_choose_base', (ctx) => {
+        const { baseIndex: destBase } = ctx.selectedValue as { baseIndex: number };
+        const data = ctx.data as { minionUid: string; minionDefId: string; fromBaseIndex: number };
+        return [moveMinion(data.minionUid, data.minionDefId, data.fromBaseIndex, destBase, 'pirate_dinghy', ctx.now)];
+    });
+
+    // 鍏ㄩ€熻埅琛岋細閫夋嫨闅忎粠鍚庯紝閫夋嫨鐩爣鍩哄湴
+    registerPromptContinuation('pirate_full_sail_choose_minion', (ctx) => {
+        const selected = ctx.selectedValue as { done?: boolean; minionUid?: string; baseIndex?: number };
+        if (selected.done) return []; // 鐜╁閫夋嫨"瀹屾垚"
+        const { minionUid, baseIndex } = selected as { minionUid: string; baseIndex: number };
+        const base = ctx.state.bases[baseIndex];
+        if (!base) return [];
+        const minion = base.minions.find(m => m.uid === minionUid);
+        if (!minion) return [];
+        const data = ctx.data as { movedUids: string[] };
+        return buildMoveToBasePrompt(
+            ctx.state, minionUid, minion.defId, baseIndex,
+            'pirate_full_sail', ctx.playerId, ctx.now,
+            { movedUids: data.movedUids },
+        );
+    });
+
+    // 鍏ㄩ€熻埅琛岋細閫夋嫨鍩哄湴鍚庣Щ鍔紝鐒跺悗寰幆閫夋嫨涓嬩竴锟?
+    registerPromptContinuation('pirate_full_sail_choose_base', (ctx) => {
+        const { baseIndex: destBase } = ctx.selectedValue as { baseIndex: number };
+        const data = ctx.data as { minionUid: string; minionDefId: string; fromBaseIndex: number; movedUids?: string[] };
+        const events: SmashUpEvent[] = [moveMinion(data.minionUid, data.minionDefId, data.fromBaseIndex, destBase, 'pirate_full_sail', ctx.now)];
+        // 寰幆锛氱户缁€夋嫨涓嬩竴涓殢锟?
+        const newMovedUids = [...(data.movedUids ?? []), data.minionUid];
+        const nextPrompt = buildFullSailChooseMinionPrompt(ctx.state, ctx.playerId, ctx.now, newMovedUids);
+        events.push(...nextPrompt);
+        return events;
+    });
+
+    // 鐐歌嵂妗讹細閫夋嫨鐗虹壊闅忎粠鍚庢墽锟?
     registerPromptContinuation('pirate_powderkeg', (ctx) => {
         const { minionUid, baseIndex } = ctx.selectedValue as { minionUid: string; baseIndex: number };
         const base = ctx.state.bases[baseIndex];
